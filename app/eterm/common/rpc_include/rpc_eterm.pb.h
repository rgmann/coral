// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc_eterm.proto

#ifndef PROTOBUF_rpc_5feterm_2eproto__INCLUDED
#define PROTOBUF_rpc_5feterm_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace rpc_eterm {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rpc_5feterm_2eproto();
void protobuf_AssignDesc_rpc_5feterm_2eproto();
void protobuf_ShutdownFile_rpc_5feterm_2eproto();

class EmptyParams;
class Status;
class AccessTime;
class UserName;
class User;
class UserList;
class UserID;
class HcSetLedState;

// ===================================================================

class EmptyParams : public ::google::protobuf::Message {
 public:
  EmptyParams();
  virtual ~EmptyParams();

  EmptyParams(const EmptyParams& from);

  inline EmptyParams& operator=(const EmptyParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmptyParams& default_instance();

  void Swap(EmptyParams* other);

  // implements Message ----------------------------------------------

  EmptyParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmptyParams& from);
  void MergeFrom(const EmptyParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:rpc_eterm.EmptyParams)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_rpc_5feterm_2eproto();
  friend void protobuf_AssignDesc_rpc_5feterm_2eproto();
  friend void protobuf_ShutdownFile_rpc_5feterm_2eproto();

  void InitAsDefaultInstance();
  static EmptyParams* default_instance_;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  void Swap(Status* other);

  // implements Message ----------------------------------------------

  Status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool connected = 1;
  inline bool has_connected() const;
  inline void clear_connected();
  static const int kConnectedFieldNumber = 1;
  inline bool connected() const;
  inline void set_connected(bool value);

  // optional bool busy = 2;
  inline bool has_busy() const;
  inline void clear_busy();
  static const int kBusyFieldNumber = 2;
  inline bool busy() const;
  inline void set_busy(bool value);

  // @@protoc_insertion_point(class_scope:rpc_eterm.Status)
 private:
  inline void set_has_connected();
  inline void clear_has_connected();
  inline void set_has_busy();
  inline void clear_has_busy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool connected_;
  bool busy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_5feterm_2eproto();
  friend void protobuf_AssignDesc_rpc_5feterm_2eproto();
  friend void protobuf_ShutdownFile_rpc_5feterm_2eproto();

  void InitAsDefaultInstance();
  static Status* default_instance_;
};
// -------------------------------------------------------------------

class AccessTime : public ::google::protobuf::Message {
 public:
  AccessTime();
  virtual ~AccessTime();

  AccessTime(const AccessTime& from);

  inline AccessTime& operator=(const AccessTime& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccessTime& default_instance();

  void Swap(AccessTime* other);

  // implements Message ----------------------------------------------

  AccessTime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccessTime& from);
  void MergeFrom(const AccessTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 seconds = 1;
  inline bool has_seconds() const;
  inline void clear_seconds();
  static const int kSecondsFieldNumber = 1;
  inline ::google::protobuf::int32 seconds() const;
  inline void set_seconds(::google::protobuf::int32 value);

  // optional int32 nanoseconds = 2;
  inline bool has_nanoseconds() const;
  inline void clear_nanoseconds();
  static const int kNanosecondsFieldNumber = 2;
  inline ::google::protobuf::int32 nanoseconds() const;
  inline void set_nanoseconds(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rpc_eterm.AccessTime)
 private:
  inline void set_has_seconds();
  inline void clear_has_seconds();
  inline void set_has_nanoseconds();
  inline void clear_has_nanoseconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 seconds_;
  ::google::protobuf::int32 nanoseconds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_5feterm_2eproto();
  friend void protobuf_AssignDesc_rpc_5feterm_2eproto();
  friend void protobuf_ShutdownFile_rpc_5feterm_2eproto();

  void InitAsDefaultInstance();
  static AccessTime* default_instance_;
};
// -------------------------------------------------------------------

class UserName : public ::google::protobuf::Message {
 public:
  UserName();
  virtual ~UserName();

  UserName(const UserName& from);

  inline UserName& operator=(const UserName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserName& default_instance();

  void Swap(UserName* other);

  // implements Message ----------------------------------------------

  UserName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserName& from);
  void MergeFrom(const UserName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string first_name = 1;
  inline bool has_first_name() const;
  inline void clear_first_name();
  static const int kFirstNameFieldNumber = 1;
  inline const ::std::string& first_name() const;
  inline void set_first_name(const ::std::string& value);
  inline void set_first_name(const char* value);
  inline void set_first_name(const char* value, size_t size);
  inline ::std::string* mutable_first_name();
  inline ::std::string* release_first_name();
  inline void set_allocated_first_name(::std::string* first_name);

  // optional string last_name = 2;
  inline bool has_last_name() const;
  inline void clear_last_name();
  static const int kLastNameFieldNumber = 2;
  inline const ::std::string& last_name() const;
  inline void set_last_name(const ::std::string& value);
  inline void set_last_name(const char* value);
  inline void set_last_name(const char* value, size_t size);
  inline ::std::string* mutable_last_name();
  inline ::std::string* release_last_name();
  inline void set_allocated_last_name(::std::string* last_name);

  // @@protoc_insertion_point(class_scope:rpc_eterm.UserName)
 private:
  inline void set_has_first_name();
  inline void clear_has_first_name();
  inline void set_has_last_name();
  inline void clear_has_last_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* first_name_;
  ::std::string* last_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_5feterm_2eproto();
  friend void protobuf_AssignDesc_rpc_5feterm_2eproto();
  friend void protobuf_ShutdownFile_rpc_5feterm_2eproto();

  void InitAsDefaultInstance();
  static UserName* default_instance_;
};
// -------------------------------------------------------------------

class User : public ::google::protobuf::Message {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();

  void Swap(User* other);

  // implements Message ----------------------------------------------

  User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // optional .rpc_eterm.UserName user_name = 2;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 2;
  inline const ::rpc_eterm::UserName& user_name() const;
  inline ::rpc_eterm::UserName* mutable_user_name();
  inline ::rpc_eterm::UserName* release_user_name();
  inline void set_allocated_user_name(::rpc_eterm::UserName* user_name);

  // optional uint32 access_count = 4;
  inline bool has_access_count() const;
  inline void clear_access_count();
  static const int kAccessCountFieldNumber = 4;
  inline ::google::protobuf::uint32 access_count() const;
  inline void set_access_count(::google::protobuf::uint32 value);

  // optional .rpc_eterm.AccessTime last_access = 5;
  inline bool has_last_access() const;
  inline void clear_last_access();
  static const int kLastAccessFieldNumber = 5;
  inline const ::rpc_eterm::AccessTime& last_access() const;
  inline ::rpc_eterm::AccessTime* mutable_last_access();
  inline ::rpc_eterm::AccessTime* release_last_access();
  inline void set_allocated_last_access(::rpc_eterm::AccessTime* last_access);

  // @@protoc_insertion_point(class_scope:rpc_eterm.User)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_access_count();
  inline void clear_has_access_count();
  inline void set_has_last_access();
  inline void clear_has_last_access();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::rpc_eterm::UserName* user_name_;
  ::google::protobuf::int32 user_id_;
  ::google::protobuf::uint32 access_count_;
  ::rpc_eterm::AccessTime* last_access_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_5feterm_2eproto();
  friend void protobuf_AssignDesc_rpc_5feterm_2eproto();
  friend void protobuf_ShutdownFile_rpc_5feterm_2eproto();

  void InitAsDefaultInstance();
  static User* default_instance_;
};
// -------------------------------------------------------------------

class UserList : public ::google::protobuf::Message {
 public:
  UserList();
  virtual ~UserList();

  UserList(const UserList& from);

  inline UserList& operator=(const UserList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserList& default_instance();

  void Swap(UserList* other);

  // implements Message ----------------------------------------------

  UserList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserList& from);
  void MergeFrom(const UserList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .rpc_eterm.User users = 2;
  inline int users_size() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 2;
  inline const ::rpc_eterm::User& users(int index) const;
  inline ::rpc_eterm::User* mutable_users(int index);
  inline ::rpc_eterm::User* add_users();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc_eterm::User >&
      users() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc_eterm::User >*
      mutable_users();

  // @@protoc_insertion_point(class_scope:rpc_eterm.UserList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::rpc_eterm::User > users_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_5feterm_2eproto();
  friend void protobuf_AssignDesc_rpc_5feterm_2eproto();
  friend void protobuf_ShutdownFile_rpc_5feterm_2eproto();

  void InitAsDefaultInstance();
  static UserList* default_instance_;
};
// -------------------------------------------------------------------

class UserID : public ::google::protobuf::Message {
 public:
  UserID();
  virtual ~UserID();

  UserID(const UserID& from);

  inline UserID& operator=(const UserID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserID& default_instance();

  void Swap(UserID* other);

  // implements Message ----------------------------------------------

  UserID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserID& from);
  void MergeFrom(const UserID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:rpc_eterm.UserID)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_5feterm_2eproto();
  friend void protobuf_AssignDesc_rpc_5feterm_2eproto();
  friend void protobuf_ShutdownFile_rpc_5feterm_2eproto();

  void InitAsDefaultInstance();
  static UserID* default_instance_;
};
// -------------------------------------------------------------------

class HcSetLedState : public ::google::protobuf::Message {
 public:
  HcSetLedState();
  virtual ~HcSetLedState();

  HcSetLedState(const HcSetLedState& from);

  inline HcSetLedState& operator=(const HcSetLedState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HcSetLedState& default_instance();

  void Swap(HcSetLedState* other);

  // implements Message ----------------------------------------------

  HcSetLedState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HcSetLedState& from);
  void MergeFrom(const HcSetLedState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 led_id = 1;
  inline bool has_led_id() const;
  inline void clear_led_id();
  static const int kLedIdFieldNumber = 1;
  inline ::google::protobuf::uint32 led_id() const;
  inline void set_led_id(::google::protobuf::uint32 value);

  // optional bool led_on = 2;
  inline bool has_led_on() const;
  inline void clear_led_on();
  static const int kLedOnFieldNumber = 2;
  inline bool led_on() const;
  inline void set_led_on(bool value);

  // @@protoc_insertion_point(class_scope:rpc_eterm.HcSetLedState)
 private:
  inline void set_has_led_id();
  inline void clear_has_led_id();
  inline void set_has_led_on();
  inline void clear_has_led_on();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 led_id_;
  bool led_on_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rpc_5feterm_2eproto();
  friend void protobuf_AssignDesc_rpc_5feterm_2eproto();
  friend void protobuf_ShutdownFile_rpc_5feterm_2eproto();

  void InitAsDefaultInstance();
  static HcSetLedState* default_instance_;
};
// ===================================================================


// ===================================================================

// EmptyParams

// -------------------------------------------------------------------

// Status

// optional bool connected = 1;
inline bool Status::has_connected() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Status::set_has_connected() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Status::clear_has_connected() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Status::clear_connected() {
  connected_ = false;
  clear_has_connected();
}
inline bool Status::connected() const {
  return connected_;
}
inline void Status::set_connected(bool value) {
  set_has_connected();
  connected_ = value;
}

// optional bool busy = 2;
inline bool Status::has_busy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Status::set_has_busy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Status::clear_has_busy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Status::clear_busy() {
  busy_ = false;
  clear_has_busy();
}
inline bool Status::busy() const {
  return busy_;
}
inline void Status::set_busy(bool value) {
  set_has_busy();
  busy_ = value;
}

// -------------------------------------------------------------------

// AccessTime

// optional int32 seconds = 1;
inline bool AccessTime::has_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccessTime::set_has_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccessTime::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccessTime::clear_seconds() {
  seconds_ = 0;
  clear_has_seconds();
}
inline ::google::protobuf::int32 AccessTime::seconds() const {
  return seconds_;
}
inline void AccessTime::set_seconds(::google::protobuf::int32 value) {
  set_has_seconds();
  seconds_ = value;
}

// optional int32 nanoseconds = 2;
inline bool AccessTime::has_nanoseconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccessTime::set_has_nanoseconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccessTime::clear_has_nanoseconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccessTime::clear_nanoseconds() {
  nanoseconds_ = 0;
  clear_has_nanoseconds();
}
inline ::google::protobuf::int32 AccessTime::nanoseconds() const {
  return nanoseconds_;
}
inline void AccessTime::set_nanoseconds(::google::protobuf::int32 value) {
  set_has_nanoseconds();
  nanoseconds_ = value;
}

// -------------------------------------------------------------------

// UserName

// optional string first_name = 1;
inline bool UserName::has_first_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserName::set_has_first_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserName::clear_has_first_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserName::clear_first_name() {
  if (first_name_ != &::google::protobuf::internal::kEmptyString) {
    first_name_->clear();
  }
  clear_has_first_name();
}
inline const ::std::string& UserName::first_name() const {
  return *first_name_;
}
inline void UserName::set_first_name(const ::std::string& value) {
  set_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    first_name_ = new ::std::string;
  }
  first_name_->assign(value);
}
inline void UserName::set_first_name(const char* value) {
  set_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    first_name_ = new ::std::string;
  }
  first_name_->assign(value);
}
inline void UserName::set_first_name(const char* value, size_t size) {
  set_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    first_name_ = new ::std::string;
  }
  first_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserName::mutable_first_name() {
  set_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    first_name_ = new ::std::string;
  }
  return first_name_;
}
inline ::std::string* UserName::release_first_name() {
  clear_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = first_name_;
    first_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserName::set_allocated_first_name(::std::string* first_name) {
  if (first_name_ != &::google::protobuf::internal::kEmptyString) {
    delete first_name_;
  }
  if (first_name) {
    set_has_first_name();
    first_name_ = first_name;
  } else {
    clear_has_first_name();
    first_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string last_name = 2;
inline bool UserName::has_last_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserName::set_has_last_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserName::clear_has_last_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserName::clear_last_name() {
  if (last_name_ != &::google::protobuf::internal::kEmptyString) {
    last_name_->clear();
  }
  clear_has_last_name();
}
inline const ::std::string& UserName::last_name() const {
  return *last_name_;
}
inline void UserName::set_last_name(const ::std::string& value) {
  set_has_last_name();
  if (last_name_ == &::google::protobuf::internal::kEmptyString) {
    last_name_ = new ::std::string;
  }
  last_name_->assign(value);
}
inline void UserName::set_last_name(const char* value) {
  set_has_last_name();
  if (last_name_ == &::google::protobuf::internal::kEmptyString) {
    last_name_ = new ::std::string;
  }
  last_name_->assign(value);
}
inline void UserName::set_last_name(const char* value, size_t size) {
  set_has_last_name();
  if (last_name_ == &::google::protobuf::internal::kEmptyString) {
    last_name_ = new ::std::string;
  }
  last_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserName::mutable_last_name() {
  set_has_last_name();
  if (last_name_ == &::google::protobuf::internal::kEmptyString) {
    last_name_ = new ::std::string;
  }
  return last_name_;
}
inline ::std::string* UserName::release_last_name() {
  clear_has_last_name();
  if (last_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = last_name_;
    last_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserName::set_allocated_last_name(::std::string* last_name) {
  if (last_name_ != &::google::protobuf::internal::kEmptyString) {
    delete last_name_;
  }
  if (last_name) {
    set_has_last_name();
    last_name_ = last_name;
  } else {
    clear_has_last_name();
    last_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// User

// optional int32 user_id = 1;
inline bool User::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 User::user_id() const {
  return user_id_;
}
inline void User::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// optional .rpc_eterm.UserName user_name = 2;
inline bool User::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void User::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void User::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void User::clear_user_name() {
  if (user_name_ != NULL) user_name_->::rpc_eterm::UserName::Clear();
  clear_has_user_name();
}
inline const ::rpc_eterm::UserName& User::user_name() const {
  return user_name_ != NULL ? *user_name_ : *default_instance_->user_name_;
}
inline ::rpc_eterm::UserName* User::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == NULL) user_name_ = new ::rpc_eterm::UserName;
  return user_name_;
}
inline ::rpc_eterm::UserName* User::release_user_name() {
  clear_has_user_name();
  ::rpc_eterm::UserName* temp = user_name_;
  user_name_ = NULL;
  return temp;
}
inline void User::set_allocated_user_name(::rpc_eterm::UserName* user_name) {
  delete user_name_;
  user_name_ = user_name;
  if (user_name) {
    set_has_user_name();
  } else {
    clear_has_user_name();
  }
}

// optional uint32 access_count = 4;
inline bool User::has_access_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void User::set_has_access_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void User::clear_has_access_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void User::clear_access_count() {
  access_count_ = 0u;
  clear_has_access_count();
}
inline ::google::protobuf::uint32 User::access_count() const {
  return access_count_;
}
inline void User::set_access_count(::google::protobuf::uint32 value) {
  set_has_access_count();
  access_count_ = value;
}

// optional .rpc_eterm.AccessTime last_access = 5;
inline bool User::has_last_access() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void User::set_has_last_access() {
  _has_bits_[0] |= 0x00000008u;
}
inline void User::clear_has_last_access() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void User::clear_last_access() {
  if (last_access_ != NULL) last_access_->::rpc_eterm::AccessTime::Clear();
  clear_has_last_access();
}
inline const ::rpc_eterm::AccessTime& User::last_access() const {
  return last_access_ != NULL ? *last_access_ : *default_instance_->last_access_;
}
inline ::rpc_eterm::AccessTime* User::mutable_last_access() {
  set_has_last_access();
  if (last_access_ == NULL) last_access_ = new ::rpc_eterm::AccessTime;
  return last_access_;
}
inline ::rpc_eterm::AccessTime* User::release_last_access() {
  clear_has_last_access();
  ::rpc_eterm::AccessTime* temp = last_access_;
  last_access_ = NULL;
  return temp;
}
inline void User::set_allocated_last_access(::rpc_eterm::AccessTime* last_access) {
  delete last_access_;
  last_access_ = last_access;
  if (last_access) {
    set_has_last_access();
  } else {
    clear_has_last_access();
  }
}

// -------------------------------------------------------------------

// UserList

// repeated .rpc_eterm.User users = 2;
inline int UserList::users_size() const {
  return users_.size();
}
inline void UserList::clear_users() {
  users_.Clear();
}
inline const ::rpc_eterm::User& UserList::users(int index) const {
  return users_.Get(index);
}
inline ::rpc_eterm::User* UserList::mutable_users(int index) {
  return users_.Mutable(index);
}
inline ::rpc_eterm::User* UserList::add_users() {
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc_eterm::User >&
UserList::users() const {
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc_eterm::User >*
UserList::mutable_users() {
  return &users_;
}

// -------------------------------------------------------------------

// UserID

// optional uint32 user_id = 1;
inline bool UserID::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserID::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserID::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserID::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 UserID::user_id() const {
  return user_id_;
}
inline void UserID::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// HcSetLedState

// optional uint32 led_id = 1;
inline bool HcSetLedState::has_led_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HcSetLedState::set_has_led_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HcSetLedState::clear_has_led_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HcSetLedState::clear_led_id() {
  led_id_ = 0u;
  clear_has_led_id();
}
inline ::google::protobuf::uint32 HcSetLedState::led_id() const {
  return led_id_;
}
inline void HcSetLedState::set_led_id(::google::protobuf::uint32 value) {
  set_has_led_id();
  led_id_ = value;
}

// optional bool led_on = 2;
inline bool HcSetLedState::has_led_on() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HcSetLedState::set_has_led_on() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HcSetLedState::clear_has_led_on() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HcSetLedState::clear_led_on() {
  led_on_ = false;
  clear_has_led_on();
}
inline bool HcSetLedState::led_on() const {
  return led_on_;
}
inline void HcSetLedState::set_led_on(bool value) {
  set_has_led_on();
  led_on_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace rpc_eterm

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rpc_5feterm_2eproto__INCLUDED
