// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc_eterm.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "rpc_eterm.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace rpc_eterm {

namespace {

const ::google::protobuf::Descriptor* EmptyParams_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EmptyParams_reflection_ = NULL;
const ::google::protobuf::Descriptor* Status_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Status_reflection_ = NULL;
const ::google::protobuf::Descriptor* AccessTime_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AccessTime_reflection_ = NULL;
const ::google::protobuf::Descriptor* UserName_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UserName_reflection_ = NULL;
const ::google::protobuf::Descriptor* User_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  User_reflection_ = NULL;
const ::google::protobuf::Descriptor* UserList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UserList_reflection_ = NULL;
const ::google::protobuf::Descriptor* UserID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UserID_reflection_ = NULL;
const ::google::protobuf::Descriptor* HcSetLedState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HcSetLedState_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_rpc_5feterm_2eproto() {
  protobuf_AddDesc_rpc_5feterm_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "rpc_eterm.proto");
  GOOGLE_CHECK(file != NULL);
  EmptyParams_descriptor_ = file->message_type(0);
  static const int EmptyParams_offsets_[1] = {
  };
  EmptyParams_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EmptyParams_descriptor_,
      EmptyParams::default_instance_,
      EmptyParams_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmptyParams, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmptyParams, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EmptyParams));
  Status_descriptor_ = file->message_type(1);
  static const int Status_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Status, connected_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Status, busy_),
  };
  Status_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Status_descriptor_,
      Status::default_instance_,
      Status_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Status, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Status, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Status));
  AccessTime_descriptor_ = file->message_type(2);
  static const int AccessTime_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccessTime, seconds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccessTime, nanoseconds_),
  };
  AccessTime_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AccessTime_descriptor_,
      AccessTime::default_instance_,
      AccessTime_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccessTime, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccessTime, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AccessTime));
  UserName_descriptor_ = file->message_type(3);
  static const int UserName_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserName, first_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserName, last_name_),
  };
  UserName_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UserName_descriptor_,
      UserName::default_instance_,
      UserName_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserName, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserName, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UserName));
  User_descriptor_ = file->message_type(4);
  static const int User_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(User, user_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(User, user_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(User, access_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(User, last_access_),
  };
  User_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      User_descriptor_,
      User::default_instance_,
      User_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(User, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(User, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(User));
  UserList_descriptor_ = file->message_type(5);
  static const int UserList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserList, users_),
  };
  UserList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UserList_descriptor_,
      UserList::default_instance_,
      UserList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UserList));
  UserID_descriptor_ = file->message_type(6);
  static const int UserID_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserID, user_id_),
  };
  UserID_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UserID_descriptor_,
      UserID::default_instance_,
      UserID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserID, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserID, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UserID));
  HcSetLedState_descriptor_ = file->message_type(7);
  static const int HcSetLedState_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HcSetLedState, led_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HcSetLedState, led_on_),
  };
  HcSetLedState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HcSetLedState_descriptor_,
      HcSetLedState::default_instance_,
      HcSetLedState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HcSetLedState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HcSetLedState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HcSetLedState));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_rpc_5feterm_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EmptyParams_descriptor_, &EmptyParams::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Status_descriptor_, &Status::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AccessTime_descriptor_, &AccessTime::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UserName_descriptor_, &UserName::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    User_descriptor_, &User::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UserList_descriptor_, &UserList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UserID_descriptor_, &UserID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HcSetLedState_descriptor_, &HcSetLedState::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_rpc_5feterm_2eproto() {
  delete EmptyParams::default_instance_;
  delete EmptyParams_reflection_;
  delete Status::default_instance_;
  delete Status_reflection_;
  delete AccessTime::default_instance_;
  delete AccessTime_reflection_;
  delete UserName::default_instance_;
  delete UserName_reflection_;
  delete User::default_instance_;
  delete User_reflection_;
  delete UserList::default_instance_;
  delete UserList_reflection_;
  delete UserID::default_instance_;
  delete UserID_reflection_;
  delete HcSetLedState::default_instance_;
  delete HcSetLedState_reflection_;
}

void protobuf_AddDesc_rpc_5feterm_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\017rpc_eterm.proto\022\trpc_eterm\"\r\n\013EmptyPar"
    "ams\")\n\006Status\022\021\n\tconnected\030\001 \001(\010\022\014\n\004busy"
    "\030\002 \001(\010\"2\n\nAccessTime\022\017\n\007seconds\030\001 \001(\005\022\023\n"
    "\013nanoseconds\030\002 \001(\005\"1\n\010UserName\022\022\n\nfirst_"
    "name\030\001 \001(\t\022\021\n\tlast_name\030\002 \001(\t\"\201\001\n\004User\022\017"
    "\n\007user_id\030\001 \001(\005\022&\n\tuser_name\030\002 \001(\0132\023.rpc"
    "_eterm.UserName\022\024\n\014access_count\030\004 \001(\r\022*\n"
    "\013last_access\030\005 \001(\0132\025.rpc_eterm.AccessTim"
    "e\"*\n\010UserList\022\036\n\005users\030\002 \003(\0132\017.rpc_eterm"
    ".User\"\031\n\006UserID\022\017\n\007user_id\030\001 \001(\r\"/\n\rHcSe"
    "tLedState\022\016\n\006led_id\030\001 \001(\r\022\016\n\006led_on\030\002 \001("
    "\010", 441);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "rpc_eterm.proto", &protobuf_RegisterTypes);
  EmptyParams::default_instance_ = new EmptyParams();
  Status::default_instance_ = new Status();
  AccessTime::default_instance_ = new AccessTime();
  UserName::default_instance_ = new UserName();
  User::default_instance_ = new User();
  UserList::default_instance_ = new UserList();
  UserID::default_instance_ = new UserID();
  HcSetLedState::default_instance_ = new HcSetLedState();
  EmptyParams::default_instance_->InitAsDefaultInstance();
  Status::default_instance_->InitAsDefaultInstance();
  AccessTime::default_instance_->InitAsDefaultInstance();
  UserName::default_instance_->InitAsDefaultInstance();
  User::default_instance_->InitAsDefaultInstance();
  UserList::default_instance_->InitAsDefaultInstance();
  UserID::default_instance_->InitAsDefaultInstance();
  HcSetLedState::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_rpc_5feterm_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_rpc_5feterm_2eproto {
  StaticDescriptorInitializer_rpc_5feterm_2eproto() {
    protobuf_AddDesc_rpc_5feterm_2eproto();
  }
} static_descriptor_initializer_rpc_5feterm_2eproto_;

// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

EmptyParams::EmptyParams()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void EmptyParams::InitAsDefaultInstance() {
}

EmptyParams::EmptyParams(const EmptyParams& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void EmptyParams::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EmptyParams::~EmptyParams() {
  SharedDtor();
}

void EmptyParams::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EmptyParams::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EmptyParams::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmptyParams_descriptor_;
}

const EmptyParams& EmptyParams::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rpc_5feterm_2eproto();
  return *default_instance_;
}

EmptyParams* EmptyParams::default_instance_ = NULL;

EmptyParams* EmptyParams::New() const {
  return new EmptyParams;
}

void EmptyParams::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EmptyParams::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void EmptyParams::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* EmptyParams::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int EmptyParams::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmptyParams::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EmptyParams* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EmptyParams*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EmptyParams::MergeFrom(const EmptyParams& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EmptyParams::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EmptyParams::CopyFrom(const EmptyParams& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmptyParams::IsInitialized() const {

  return true;
}

void EmptyParams::Swap(EmptyParams* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EmptyParams::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EmptyParams_descriptor_;
  metadata.reflection = EmptyParams_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Status::kConnectedFieldNumber;
const int Status::kBusyFieldNumber;
#endif  // !_MSC_VER

Status::Status()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Status::InitAsDefaultInstance() {
}

Status::Status(const Status& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Status::SharedCtor() {
  _cached_size_ = 0;
  connected_ = false;
  busy_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Status::~Status() {
  SharedDtor();
}

void Status::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Status::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Status::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Status_descriptor_;
}

const Status& Status::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rpc_5feterm_2eproto();
  return *default_instance_;
}

Status* Status::default_instance_ = NULL;

Status* Status::New() const {
  return new Status;
}

void Status::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    connected_ = false;
    busy_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Status::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool connected = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &connected_)));
          set_has_connected();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_busy;
        break;
      }

      // optional bool busy = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_busy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &busy_)));
          set_has_busy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Status::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool connected = 1;
  if (has_connected()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->connected(), output);
  }

  // optional bool busy = 2;
  if (has_busy()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->busy(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Status::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bool connected = 1;
  if (has_connected()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->connected(), target);
  }

  // optional bool busy = 2;
  if (has_busy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->busy(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Status::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool connected = 1;
    if (has_connected()) {
      total_size += 1 + 1;
    }

    // optional bool busy = 2;
    if (has_busy()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Status::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Status* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Status*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Status::MergeFrom(const Status& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_connected()) {
      set_connected(from.connected());
    }
    if (from.has_busy()) {
      set_busy(from.busy());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Status::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Status::CopyFrom(const Status& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Status::IsInitialized() const {

  return true;
}

void Status::Swap(Status* other) {
  if (other != this) {
    std::swap(connected_, other->connected_);
    std::swap(busy_, other->busy_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Status::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Status_descriptor_;
  metadata.reflection = Status_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AccessTime::kSecondsFieldNumber;
const int AccessTime::kNanosecondsFieldNumber;
#endif  // !_MSC_VER

AccessTime::AccessTime()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AccessTime::InitAsDefaultInstance() {
}

AccessTime::AccessTime(const AccessTime& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AccessTime::SharedCtor() {
  _cached_size_ = 0;
  seconds_ = 0;
  nanoseconds_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AccessTime::~AccessTime() {
  SharedDtor();
}

void AccessTime::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AccessTime::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AccessTime::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AccessTime_descriptor_;
}

const AccessTime& AccessTime::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rpc_5feterm_2eproto();
  return *default_instance_;
}

AccessTime* AccessTime::default_instance_ = NULL;

AccessTime* AccessTime::New() const {
  return new AccessTime;
}

void AccessTime::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    seconds_ = 0;
    nanoseconds_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AccessTime::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 seconds = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seconds_)));
          set_has_seconds();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_nanoseconds;
        break;
      }

      // optional int32 nanoseconds = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nanoseconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nanoseconds_)));
          set_has_nanoseconds();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AccessTime::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 seconds = 1;
  if (has_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->seconds(), output);
  }

  // optional int32 nanoseconds = 2;
  if (has_nanoseconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->nanoseconds(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AccessTime::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 seconds = 1;
  if (has_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->seconds(), target);
  }

  // optional int32 nanoseconds = 2;
  if (has_nanoseconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->nanoseconds(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AccessTime::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 seconds = 1;
    if (has_seconds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seconds());
    }

    // optional int32 nanoseconds = 2;
    if (has_nanoseconds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nanoseconds());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AccessTime::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AccessTime* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AccessTime*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AccessTime::MergeFrom(const AccessTime& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seconds()) {
      set_seconds(from.seconds());
    }
    if (from.has_nanoseconds()) {
      set_nanoseconds(from.nanoseconds());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AccessTime::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AccessTime::CopyFrom(const AccessTime& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccessTime::IsInitialized() const {

  return true;
}

void AccessTime::Swap(AccessTime* other) {
  if (other != this) {
    std::swap(seconds_, other->seconds_);
    std::swap(nanoseconds_, other->nanoseconds_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AccessTime::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AccessTime_descriptor_;
  metadata.reflection = AccessTime_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UserName::kFirstNameFieldNumber;
const int UserName::kLastNameFieldNumber;
#endif  // !_MSC_VER

UserName::UserName()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UserName::InitAsDefaultInstance() {
}

UserName::UserName(const UserName& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UserName::SharedCtor() {
  _cached_size_ = 0;
  first_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  last_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserName::~UserName() {
  SharedDtor();
}

void UserName::SharedDtor() {
  if (first_name_ != &::google::protobuf::internal::kEmptyString) {
    delete first_name_;
  }
  if (last_name_ != &::google::protobuf::internal::kEmptyString) {
    delete last_name_;
  }
  if (this != default_instance_) {
  }
}

void UserName::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UserName::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UserName_descriptor_;
}

const UserName& UserName::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rpc_5feterm_2eproto();
  return *default_instance_;
}

UserName* UserName::default_instance_ = NULL;

UserName* UserName::New() const {
  return new UserName;
}

void UserName::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_first_name()) {
      if (first_name_ != &::google::protobuf::internal::kEmptyString) {
        first_name_->clear();
      }
    }
    if (has_last_name()) {
      if (last_name_ != &::google::protobuf::internal::kEmptyString) {
        last_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UserName::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string first_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_first_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->first_name().data(), this->first_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_last_name;
        break;
      }

      // optional string last_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_last_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_last_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->last_name().data(), this->last_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UserName::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string first_name = 1;
  if (has_first_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->first_name().data(), this->first_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->first_name(), output);
  }

  // optional string last_name = 2;
  if (has_last_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->last_name().data(), this->last_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->last_name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UserName::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string first_name = 1;
  if (has_first_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->first_name().data(), this->first_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->first_name(), target);
  }

  // optional string last_name = 2;
  if (has_last_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->last_name().data(), this->last_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->last_name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UserName::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string first_name = 1;
    if (has_first_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->first_name());
    }

    // optional string last_name = 2;
    if (has_last_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->last_name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserName::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UserName* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UserName*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UserName::MergeFrom(const UserName& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_first_name()) {
      set_first_name(from.first_name());
    }
    if (from.has_last_name()) {
      set_last_name(from.last_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UserName::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UserName::CopyFrom(const UserName& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserName::IsInitialized() const {

  return true;
}

void UserName::Swap(UserName* other) {
  if (other != this) {
    std::swap(first_name_, other->first_name_);
    std::swap(last_name_, other->last_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UserName::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UserName_descriptor_;
  metadata.reflection = UserName_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int User::kUserIdFieldNumber;
const int User::kUserNameFieldNumber;
const int User::kAccessCountFieldNumber;
const int User::kLastAccessFieldNumber;
#endif  // !_MSC_VER

User::User()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void User::InitAsDefaultInstance() {
  user_name_ = const_cast< ::rpc_eterm::UserName*>(&::rpc_eterm::UserName::default_instance());
  last_access_ = const_cast< ::rpc_eterm::AccessTime*>(&::rpc_eterm::AccessTime::default_instance());
}

User::User(const User& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void User::SharedCtor() {
  _cached_size_ = 0;
  user_id_ = 0;
  user_name_ = NULL;
  access_count_ = 0u;
  last_access_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

User::~User() {
  SharedDtor();
}

void User::SharedDtor() {
  if (this != default_instance_) {
    delete user_name_;
    delete last_access_;
  }
}

void User::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* User::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return User_descriptor_;
}

const User& User::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rpc_5feterm_2eproto();
  return *default_instance_;
}

User* User::default_instance_ = NULL;

User* User::New() const {
  return new User;
}

void User::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    user_id_ = 0;
    if (has_user_name()) {
      if (user_name_ != NULL) user_name_->::rpc_eterm::UserName::Clear();
    }
    access_count_ = 0u;
    if (has_last_access()) {
      if (last_access_ != NULL) last_access_->::rpc_eterm::AccessTime::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool User::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 user_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user_name;
        break;
      }

      // optional .rpc_eterm.UserName user_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_access_count;
        break;
      }

      // optional uint32 access_count = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_access_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &access_count_)));
          set_has_access_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_last_access;
        break;
      }

      // optional .rpc_eterm.AccessTime last_access = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_last_access:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_last_access()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void User::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->user_id(), output);
  }

  // optional .rpc_eterm.UserName user_name = 2;
  if (has_user_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->user_name(), output);
  }

  // optional uint32 access_count = 4;
  if (has_access_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->access_count(), output);
  }

  // optional .rpc_eterm.AccessTime last_access = 5;
  if (has_last_access()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->last_access(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* User::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 user_id = 1;
  if (has_user_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->user_id(), target);
  }

  // optional .rpc_eterm.UserName user_name = 2;
  if (has_user_name()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->user_name(), target);
  }

  // optional uint32 access_count = 4;
  if (has_access_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->access_count(), target);
  }

  // optional .rpc_eterm.AccessTime last_access = 5;
  if (has_last_access()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->last_access(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int User::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->user_id());
    }

    // optional .rpc_eterm.UserName user_name = 2;
    if (has_user_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->user_name());
    }

    // optional uint32 access_count = 4;
    if (has_access_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->access_count());
    }

    // optional .rpc_eterm.AccessTime last_access = 5;
    if (has_last_access()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->last_access());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void User::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const User* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const User*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void User::MergeFrom(const User& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_user_name()) {
      mutable_user_name()->::rpc_eterm::UserName::MergeFrom(from.user_name());
    }
    if (from.has_access_count()) {
      set_access_count(from.access_count());
    }
    if (from.has_last_access()) {
      mutable_last_access()->::rpc_eterm::AccessTime::MergeFrom(from.last_access());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void User::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void User::CopyFrom(const User& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool User::IsInitialized() const {

  return true;
}

void User::Swap(User* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(user_name_, other->user_name_);
    std::swap(access_count_, other->access_count_);
    std::swap(last_access_, other->last_access_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata User::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = User_descriptor_;
  metadata.reflection = User_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UserList::kUsersFieldNumber;
#endif  // !_MSC_VER

UserList::UserList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UserList::InitAsDefaultInstance() {
}

UserList::UserList(const UserList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UserList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserList::~UserList() {
  SharedDtor();
}

void UserList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UserList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UserList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UserList_descriptor_;
}

const UserList& UserList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rpc_5feterm_2eproto();
  return *default_instance_;
}

UserList* UserList::default_instance_ = NULL;

UserList* UserList::New() const {
  return new UserList;
}

void UserList::Clear() {
  users_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UserList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .rpc_eterm.User users = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_users:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_users()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_users;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UserList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .rpc_eterm.User users = 2;
  for (int i = 0; i < this->users_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->users(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UserList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .rpc_eterm.User users = 2;
  for (int i = 0; i < this->users_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->users(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UserList::ByteSize() const {
  int total_size = 0;

  // repeated .rpc_eterm.User users = 2;
  total_size += 1 * this->users_size();
  for (int i = 0; i < this->users_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->users(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UserList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UserList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UserList::MergeFrom(const UserList& from) {
  GOOGLE_CHECK_NE(&from, this);
  users_.MergeFrom(from.users_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UserList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UserList::CopyFrom(const UserList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserList::IsInitialized() const {

  return true;
}

void UserList::Swap(UserList* other) {
  if (other != this) {
    users_.Swap(&other->users_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UserList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UserList_descriptor_;
  metadata.reflection = UserList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UserID::kUserIdFieldNumber;
#endif  // !_MSC_VER

UserID::UserID()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UserID::InitAsDefaultInstance() {
}

UserID::UserID(const UserID& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UserID::SharedCtor() {
  _cached_size_ = 0;
  user_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserID::~UserID() {
  SharedDtor();
}

void UserID::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UserID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UserID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UserID_descriptor_;
}

const UserID& UserID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rpc_5feterm_2eproto();
  return *default_instance_;
}

UserID* UserID::default_instance_ = NULL;

UserID* UserID::New() const {
  return new UserID;
}

void UserID::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    user_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UserID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 user_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UserID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UserID::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 user_id = 1;
  if (has_user_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->user_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UserID::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserID::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UserID* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UserID*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UserID::MergeFrom(const UserID& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UserID::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UserID::CopyFrom(const UserID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserID::IsInitialized() const {

  return true;
}

void UserID::Swap(UserID* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UserID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UserID_descriptor_;
  metadata.reflection = UserID_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HcSetLedState::kLedIdFieldNumber;
const int HcSetLedState::kLedOnFieldNumber;
#endif  // !_MSC_VER

HcSetLedState::HcSetLedState()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HcSetLedState::InitAsDefaultInstance() {
}

HcSetLedState::HcSetLedState(const HcSetLedState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HcSetLedState::SharedCtor() {
  _cached_size_ = 0;
  led_id_ = 0u;
  led_on_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HcSetLedState::~HcSetLedState() {
  SharedDtor();
}

void HcSetLedState::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HcSetLedState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HcSetLedState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HcSetLedState_descriptor_;
}

const HcSetLedState& HcSetLedState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rpc_5feterm_2eproto();
  return *default_instance_;
}

HcSetLedState* HcSetLedState::default_instance_ = NULL;

HcSetLedState* HcSetLedState::New() const {
  return new HcSetLedState;
}

void HcSetLedState::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    led_id_ = 0u;
    led_on_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HcSetLedState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 led_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &led_id_)));
          set_has_led_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_led_on;
        break;
      }

      // optional bool led_on = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_led_on:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &led_on_)));
          set_has_led_on();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HcSetLedState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 led_id = 1;
  if (has_led_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->led_id(), output);
  }

  // optional bool led_on = 2;
  if (has_led_on()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->led_on(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HcSetLedState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 led_id = 1;
  if (has_led_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->led_id(), target);
  }

  // optional bool led_on = 2;
  if (has_led_on()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->led_on(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HcSetLedState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 led_id = 1;
    if (has_led_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->led_id());
    }

    // optional bool led_on = 2;
    if (has_led_on()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HcSetLedState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HcSetLedState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HcSetLedState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HcSetLedState::MergeFrom(const HcSetLedState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_led_id()) {
      set_led_id(from.led_id());
    }
    if (from.has_led_on()) {
      set_led_on(from.led_on());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HcSetLedState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HcSetLedState::CopyFrom(const HcSetLedState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HcSetLedState::IsInitialized() const {

  return true;
}

void HcSetLedState::Swap(HcSetLedState* other) {
  if (other != this) {
    std::swap(led_id_, other->led_id_);
    std::swap(led_on_, other->led_on_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HcSetLedState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HcSetLedState_descriptor_;
  metadata.reflection = HcSetLedState_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace rpc_eterm

// @@protoc_insertion_point(global_scope)
