#include "RsyncAssemblyInstr.h"

//------------------------------------------------------------------------------
RsyncAssemblyInstr::RsyncAssemblyInstr()
{
   m_Header.type = RsyncTypeNotSet;
   memset(&m_Header.info, 0, sizeof(m_Header.info));
   m_pData = NULL;
}

//------------------------------------------------------------------------------
RsyncAssemblyInstr::RsyncAssemblyInstr(RsynAssmbInstrType type,
                                       unsigned int nParam)
{
   m_Header.type = type;
   m_Header.info.generic = nParam;
   m_pData = NULL;
}

//------------------------------------------------------------------------------
RsyncAssemblyInstr::~RsyncAssemblyInstr()
{
   destroy();
}

//------------------------------------------------------------------------------
bool RsyncAssemblyInstr::allocate()
{
   if (m_Header.type != RsyncChunkType)
   {
      return false;
   }
   
   m_pData = new unsigned char[m_Header.info.chunkSizeBytes];
   if (m_pData == NULL)
   {
      return false;
   }
   
   return true;
}

//------------------------------------------------------------------------------
void RsyncAssemblyInstr::destroy()
{
   if (m_pData)
   {
      delete[] m_pData;
      m_pData = NULL;
   }
}

//------------------------------------------------------------------------------
RsyncAssemblyInstrHdr* const RsyncAssemblyInstr::headerPtr()
{
   return &m_Header;
}

//------------------------------------------------------------------------------
void* const RsyncAssemblyInstr::dataPtr()
{
   return (void*)&m_pData;
}

//------------------------------------------------------------------------------
unsigned int RsyncAssemblyInstr::dataSize() const
{
   if (m_pData == NULL)
   {
      return 0;
   }
   
   return m_Header.info.chunkSizeBytes;
}

//------------------------------------------------------------------------------
bool RsyncAssemblyInstr::pack(void** pData, unsigned int &nPktSizeBytes) const
{
   unsigned char* l_pData = (unsigned char*)(*pData);
   
   if (l_pData != NULL)
   {
      return false;
   }
   
   nPktSizeBytes = sizeof(RsyncAssemblyInstrHdr) +
                     m_Header.info.chunkSizeBytes;
   
   l_pData = new unsigned char[nPktSizeBytes];
   if (l_pData == NULL)
   {
      nPktSizeBytes = 0;
      return false;
   }
   
   //  TODO: Will network-to-host byte swapping take place here?
   memcpy(l_pData, &m_Header, sizeof(m_Header));
   memcpy(l_pData + sizeof(m_Header), m_pData, dataSize());
   
   return true;
}

//------------------------------------------------------------------------------
bool RsyncAssemblyInstr::unpack(void* pData, unsigned int nPktSizeBytes)
{
   RsyncAssemblyInstrHdr* l_pHeader = pData;
   
   if (l_pHeader == NULL || nPktSizeBytes < sizeof(RsyncAssemblyInstrHdr))
   {
      return false;
   }
   
   // Validate the marker
   if (l_pHeader != m_Header.marker)
   {
      return false;
   }
   
   //  TODO: Will network-to-host byte swapping take place here?
   m_Header.type = l_pHeader->type;
   m_Header.info.generic = l_pHeader->info.generic;
   
   // If this is a chunk instruction, allocate the data section.
   if (m_Header.type == RsyncChunkType)
   {
      // Validate the size of the packet against the indicated payload size.
      if ((nPktSizeBytes - sizeof(RsyncAssemblyInstrHdr)) !=
          m_Header.info.chunkSizeBytes)
      {
         return false;
      }
      
      // Deallocate the data section if it is already allocated.
      destroy();
      
      // Re-allocate it to the appropriate size.
      if (!allocate())
      {
         return false;
      }
      
      // Copy the data chunk.
      memcpy(m_pData,
             pData + sizeof(RsyncAssemblyInstrHdr),
             m_Header.info.chunkSizeBytes);
   }
   
   return true;
}
